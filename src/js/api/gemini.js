import { geminiModels } from '../utils/constants.js';

/**
 * Gemini API wrapper class
 * Handles all interactions with Google's Gemini API
 */
export class GeminiAPI {
    constructor(apiKey, model = 'flash-lite') {
        this.apiKey = apiKey;
        this.model = model;
        this.baseUrl = 'https://generativelanguage.googleapis.com/v1beta/models';
    }

    /**
     * Update the model being used
     */
    setModel(model) {
        this.model = model;
    }

    /**
     * Get the full API endpoint for the current model
     */
    getEndpoint() {
        const modelName = geminiModels[this.model];
        return `${this.baseUrl}/${modelName}:generateContent`;
    }

    /**
     * Make a request to the Gemini API
     */
    async makeRequest(prompt, systemPrompt = null) {
        try {
            const messages = [];
            
            if (systemPrompt) {
                messages.push({
                    role: "user",
                    parts: [{ text: systemPrompt }]
                });
                messages.push({
                    role: "model", 
                    parts: [{ text: "I understand. I'll follow these instructions carefully." }]
                });
            }
            
            messages.push({
                role: "user",
                parts: [{ text: prompt }]
            });

            const response = await fetch(`${this.getEndpoint()}?key=${this.apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    contents: messages,
                    generationConfig: {
                        temperature: 0.7,
                        topK: 40,
                        topP: 0.95,
                        maxOutputTokens: 2048
                    }
                })
            });

            if (!response.ok) {
                const errorData = await response.text();
                throw new Error(`API Error ${response.status}: ${errorData}`);
            }

            const data = await response.json();
            
            if (!data.candidates?.[0]?.content?.parts?.[0]?.text) {
                throw new Error('No content generated by API');
            }

            return data.candidates[0].content.parts[0].text.trim();
        } catch (error) {
            console.error('Gemini API Error:', error);
            throw new Error(`AI service error: ${error.message}`);
        }
    }

    /**
     * Make a structured request with JSON schema
     */
    async makeStructuredRequest(prompt, schema, systemPrompt = null) {
        try {
            const messages = [];
            
            if (systemPrompt) {
                messages.push({
                    role: "user",
                    parts: [{ text: systemPrompt }]
                });
                messages.push({
                    role: "model", 
                    parts: [{ text: "I understand. I'll follow these instructions carefully." }]
                });
            }
            
            messages.push({
                role: "user",
                parts: [{ text: prompt }]
            });

            const requestBody = {
                contents: messages,
                generationConfig: {
                    temperature: 0.7,
                    topK: 40,
                    topP: 0.95,
                    maxOutputTokens: 2048,
                    responseMimeType: "application/json",
                    responseSchema: schema
                }
            };

            const response = await fetch(`${this.getEndpoint()}?key=${this.apiKey}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestBody)
            });

            if (!response.ok) {
                const errorData = await response.text();
                throw new Error(`API Error ${response.status}: ${errorData}`);
            }

            const data = await response.json();
            if (!data.candidates?.[0]?.content?.parts?.[0]?.text) {
                throw new Error('No content generated by API');
            }

            return data.candidates[0].content.parts[0].text.trim();
        } catch (error) {
            console.error('Gemini API Error:', error);
            throw new Error(`AI service error: ${error.message}`);
        }
    }

    /**
     * Validate API key by making a simple test request
     */
    async validateApiKey() {
        try {
            await this.makeRequest('Hello, please respond with "API key validated"');
            return { valid: true };
        } catch (error) {
            return { 
                valid: false, 
                error: error.message.includes('403') ? 'Invalid API key' : 'Connection failed'
            };
        }
    }

    /**
     * Generate a story based on parameters
     */
    async generateStory(language, level, theme, variant) {
        const systemPrompt = `You are a language learning story generator. Generate stories that strictly adhere to CEFR language proficiency levels. Your stories must be educational, engaging, and precisely calibrated to the specified difficulty level.`;
        
        const prompt = `Write a short story in ${language} STRICTLY following ${level.toUpperCase()} CEFR level requirements:

STRICT CEFR ${level.toUpperCase()} REQUIREMENTS:
- VOCABULARY: ${this.getCEFRSpec(level, 'vocabulary')}
- GRAMMAR: ${this.getCEFRSpec(level, 'grammar')} 
- SENTENCES: ${this.getCEFRSpec(level, 'sentences')}
- COMPLEXITY: ${this.getCEFRSpec(level, 'complexity')}

Story theme: ${theme} (specifically: ${variant})

Requirements:
- Length: 100-150 words for ${level.toUpperCase()}
- Use ONLY vocabulary appropriate for ${level.toUpperCase()} level
- Use ONLY grammar structures appropriate for ${level.toUpperCase()} level
- Make it engaging and culturally appropriate
- Focus on everyday, relatable situations

Generate ONLY the story text, no additional commentary.`;

        return await this.makeRequest(prompt, systemPrompt);
    }

    /**
     * Generate a story as structured sentences for sentence-by-sentence translation
     */
    async generateStructuredStory(language, level, theme, variant) {
        const systemPrompt = `You are a language learning story generator. Generate stories that strictly adhere to CEFR language proficiency levels. Your stories must be educational, engaging, and precisely calibrated to the specified difficulty level.`;
        
        const prompt = `Write a short story in ${language} STRICTLY following ${level.toUpperCase()} CEFR level requirements:

STRICT CEFR ${level.toUpperCase()} REQUIREMENTS:
- VOCABULARY: ${this.getCEFRSpec(level, 'vocabulary')}
- GRAMMAR: ${this.getCEFRSpec(level, 'grammar')} 
- SENTENCES: ${this.getCEFRSpec(level, 'sentences')}
- COMPLEXITY: ${this.getCEFRSpec(level, 'complexity')}

Story theme: ${theme} (specifically: ${variant})

Requirements:
- Length: 100-150 words for ${level.toUpperCase()}
- Use ONLY vocabulary appropriate for ${level.toUpperCase()} level
- Use ONLY grammar structures appropriate for ${level.toUpperCase()} level
- Make it engaging and culturally appropriate
- Focus on everyday, relatable situations
- Generate exactly 6-10 sentences (maximum 10 sentences)

Break the story into individual sentences for translation practice.`;

        const schema = {
            type: "object",
            properties: {
                sentences: {
                    type: "array",
                    items: {
                        type: "string"
                    },
                    minItems: 6,
                    maxItems: 10,
                    description: "Array of individual sentences that make up the story (6-10 sentences maximum)"
                }
            },
            required: ["sentences"]
        };

        try {
            const response = await this.makeStructuredRequest(prompt, schema, systemPrompt);
            const parsed = JSON.parse(response);
            let sentences = parsed.sentences || [];
            // Ensure max 10 sentences
            return sentences.slice(0, 10);
        } catch (error) {
            console.error('Structured generation failed, falling back to regular generation:', error);
            // Fallback: use regular generation and parse manually
            const fallbackResponse = await this.makeRequest(prompt, systemPrompt);
            
            // Try to extract JSON from markdown code blocks
            const jsonMatch = fallbackResponse.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
            if (jsonMatch) {
                try {
                    const parsed = JSON.parse(jsonMatch[1]);
                    let sentences = parsed.sentences || [];
                    // Ensure max 10 sentences
                    return sentences.slice(0, 10);
                } catch (parseError) {
                    console.error('Failed to parse extracted JSON:', parseError);
                }
            }
            
            // Final fallback: split by sentences
            let sentences = fallbackResponse.split(/[.!?]+/).filter(s => s.trim().length > 0).map(s => s.trim() + '.');
            // Ensure max 10 sentences
            return sentences.slice(0, 10);
        }
    }

    /**
     * Get CEFR specification for a given level and aspect
     */
    getCEFRSpec(level, aspect) {
        const specs = {
            a1: {
                vocabulary: "High frequency words (most common 1000-1500 words), basic nouns, verbs, adjectives",
                grammar: "Present tense, simple past, basic sentence structures, no subordinate clauses",
                sentences: "Very short sentences (5-8 words average), simple subject-verb-object structure",
                complexity: "Single ideas per sentence, no complex connections between ideas, concrete situations only"
            },
            a2: {
                vocabulary: "Common words (2000-2500 words), routine activities, personal information, basic emotions",
                grammar: "Present, past, future tenses, basic modal verbs (can, must, should), simple conditionals",
                sentences: "Short sentences (8-12 words), some compound sentences with 'and', 'but', 'or'",
                complexity: "Simple connections between ideas, familiar topics, basic cause and effect"
            },
            b1: {
                vocabulary: "Extended vocabulary (3000-4000 words), abstract concepts, opinions, experiences",
                grammar: "All major tenses, conditional sentences, passive voice, relative clauses",
                sentences: "Medium length sentences (12-18 words), complex sentences with subordinate clauses",
                complexity: "Clear connections between ideas, arguments, hypothetical situations, past experiences"
            },
            b2: {
                vocabulary: "Wide vocabulary (4000-6000 words), specialized terms, nuanced expressions",
                grammar: "Advanced structures, subjunctive mood, complex conditionals, advanced passive constructions", 
                sentences: "Longer sentences (15-25 words), sophisticated linking, varied sentence structures",
                complexity: "Abstract ideas, detailed arguments, implicit meanings, cultural references"
            },
            c1: {
                vocabulary: "Extensive vocabulary (6000+ words), idiomatic expressions, sophisticated terms",
                grammar: "All grammatical structures, subtle distinctions, stylistic variations",
                sentences: "Complex sentences (20+ words), sophisticated discourse markers, varied rhetorical devices",
                complexity: "Nuanced arguments, cultural subtleties, implicit meanings, sophisticated humor"
            }
        };
        
        return specs[level.toLowerCase()]?.[aspect] || '';
    }

    /**
     * Translate text and provide reference
     */
    async translateText(text, fromLang, toLang) {
        const prompt = `Translate this ${fromLang} text to ${toLang}. Provide only the translation, no explanations:

${text}`;

        return await this.makeRequest(prompt);
    }

    /**
     * Rate and provide feedback on a translation
     */
    async rateTranslation(originalText, userTranslation, referenceTranslation, fromLang, toLang) {
        const prompt = `As a language teacher, evaluate this translation:

ORIGINAL (${fromLang}): ${originalText}

STUDENT TRANSLATION (${toLang}): ${userTranslation}

REFERENCE TRANSLATION (${toLang}): ${referenceTranslation}

Provide detailed feedback in this format:
**Score: X/10**

**What you did well:**
- [positive points]

**Areas for improvement:**
- [specific issues with corrections]

**Key takeaways:**
- [important lessons]

Be encouraging but specific about errors.`;

        return await this.makeRequest(prompt);
    }

    /**
     * Rate multiple sentence translations in a single request
     */
    async rateSentenceTranslations(sentences, userTranslations, sourceLanguage, targetLanguage) {
        // Filter out empty translations
        const translatedPairs = sentences.map((sentence, index) => ({
            original: sentence,
            translation: userTranslations[index] || '',
            index: index
        })).filter(pair => pair.translation.trim().length > 0);

        if (translatedPairs.length === 0) {
            throw new Error('Please translate at least one sentence before submitting');
        }

        // Build comprehensive prompt for all sentences at once
        const sentenceList = translatedPairs.map((pair, idx) => 
            `${idx + 1}. ORIGINAL (${sourceLanguage}): "${pair.original}"
   STUDENT TRANSLATION (${targetLanguage}): "${pair.translation}"`
        ).join('\n\n');

        const prompt = `As a language teacher, evaluate these sentence translations and provide both individual feedback and an overall assessment.

SENTENCES TO EVALUATE:
${sentenceList}

For each sentence, provide:
1. A reference translation
2. Brief feedback covering accuracy, grammar, and word choice
3. Specific suggestions for improvement

Then provide an overall summary of the student's performance with 2-3 key learning points.

Format your response as JSON with this structure:
{
  "sentenceEvaluations": [
    {
      "sentenceNumber": 1,
      "referenceTranslation": "correct translation here",
      "feedback": "brief feedback here"
    }
  ],
  "overallFeedback": "overall assessment and learning points here",
  "translatedCount": ${translatedPairs.length},
  "totalSentences": ${sentences.length}
}`;

        try {
            const response = await this.makeRequest(prompt);
            
            // Try to parse JSON response
            let parsedResponse;
            try {
                parsedResponse = JSON.parse(response);
            } catch (parseError) {
                // Try to extract JSON from markdown code blocks
                const jsonMatch = response.match(/```(?:json)?\s*(\{[\s\S]*?\})\s*```/);
                if (jsonMatch) {
                    parsedResponse = JSON.parse(jsonMatch[1]);
                } else {
                    throw new Error('Could not parse AI response as JSON');
                }
            }

            // Transform response to match expected format
            const sentenceFeedback = translatedPairs.map((pair, idx) => {
                const evaluation = parsedResponse.sentenceEvaluations?.[idx] || {};
                return {
                    sentenceIndex: pair.index,
                    original: pair.original,
                    userTranslation: pair.translation,
                    referenceTranslation: evaluation.referenceTranslation || 'Reference not provided',
                    feedback: evaluation.feedback || 'Feedback not provided'
                };
            });

            return {
                sentenceFeedback,
                overallFeedback: parsedResponse.overallFeedback || 'Overall feedback not provided',
                totalSentences: sentences.length,
                translatedCount: translatedPairs.length
            };

        } catch (error) {
            console.error('Batch sentence evaluation failed, falling back to individual evaluation:', error);
            
            // Fallback to original approach if batch fails
            return await this.rateSentenceTranslationsIndividual(sentences, userTranslations, sourceLanguage, targetLanguage);
        }
    }

    /**
     * Fallback: Rate sentence translations individually (original approach)
     */
    async rateSentenceTranslationsIndividual(sentences, userTranslations, sourceLanguage, targetLanguage) {
        const translatedPairs = sentences.map((sentence, index) => ({
            original: sentence,
            translation: userTranslations[index] || '',
            index: index
        })).filter(pair => pair.translation.trim().length > 0);

        // Get reference translations for submitted sentences
        const referencePromises = translatedPairs.map(pair => 
            this.translateText(pair.original, sourceLanguage, targetLanguage)
        );
        const referenceTranslations = await Promise.all(referencePromises);

        // Create feedback for each translated sentence
        const feedbackPromises = translatedPairs.map((pair, idx) => {
            const prompt = `As a language teacher, evaluate this sentence translation:

ORIGINAL (${sourceLanguage}): ${pair.original}

STUDENT TRANSLATION (${targetLanguage}): ${pair.translation}

REFERENCE TRANSLATION (${targetLanguage}): ${referenceTranslations[idx]}

Provide concise feedback focusing on accuracy, grammar, and word choice.`;

            return this.makeRequest(prompt);
        });

        const individualFeedback = await Promise.all(feedbackPromises);

        // Create overall summary
        const overallPrompt = `Summarize the student's translation performance for ${translatedPairs.length} out of ${sentences.length} sentences. Provide 2-3 key learning points for improvement.`;
        const overallFeedback = await this.makeRequest(overallPrompt);

        return {
            sentenceFeedback: translatedPairs.map((pair, idx) => ({
                sentenceIndex: pair.index,
                original: pair.original,
                userTranslation: pair.translation,
                referenceTranslation: referenceTranslations[idx],
                feedback: individualFeedback[idx]
            })),
            overallFeedback,
            totalSentences: sentences.length,
            translatedCount: translatedPairs.length
        };
    }

    /**
     * Generate a mini lesson based on translation errors
     */
    async generateMiniLesson(originalText, userTranslation, fromLang, toLang) {
        const prompt = `Create a focused mini-lesson based on this translation attempt:

ORIGINAL (${fromLang}): ${originalText}
STUDENT ATTEMPT (${toLang}): ${userTranslation}

Create a mini-lesson covering:
1. **Grammar Focus**: Main grammatical concepts
2. **Vocabulary**: Key words and their usage
3. **Practice**: 2-3 simple exercises

Keep it concise and practical.`;

        return await this.makeRequest(prompt);
    }

    /**
     * Generate mini lesson based on sentence translations
     */
    async generateSentenceMiniLesson(userTranslations, fromLang, toLang) {
        const translationList = userTranslations.map((item, idx) => 
            `${idx + 1}. ORIGINAL (${fromLang}): "${item.original}"
   STUDENT TRANSLATION (${toLang}): "${item.translation}"`
        ).join('\n\n');

        const schema = {
            type: "object",
            properties: {
                title: {
                    type: "string",
                    description: "Title for the mini lesson (e.g., 'Verb Conjugation and Word Order')"
                },
                grammarFocus: {
                    type: "string",
                    description: "Main grammatical patterns and structures the student should learn"
                },
                vocabulary: {
                    type: "array",
                    items: {
                        type: "object",
                        properties: {
                            word: { type: "string", description: "The vocabulary word" },
                            meaning: { type: "string", description: "English translation/meaning" },
                            example: { type: "string", description: "Example sentence using the word" }
                        },
                        required: ["word", "meaning", "example"]
                    },
                    description: "Key vocabulary words from the translations"
                },
                commonMistakes: {
                    type: "array",
                    items: {
                        type: "object",
                        properties: {
                            mistake: { type: "string", description: "The common mistake pattern" },
                            correction: { type: "string", description: "How to fix it" },
                            example: { type: "string", description: "Correct example sentence" }
                        },
                        required: ["mistake", "correction", "example"]
                    },
                    description: "Common mistake patterns from student translations"
                },
                exercises: {
                    type: "array",
                    items: {
                        type: "object",
                        properties: {
                            type: { 
                                type: "string", 
                                enum: ["translation", "fill-in-blank", "conjugation"],
                                description: "Type of exercise"
                            },
                            instruction: { type: "string", description: "Instructions for the exercise" },
                            question: { type: "string", description: "The exercise question/prompt" },
                            answer: { type: "string", description: "The correct answer" },
                            explanation: { type: "string", description: "Why this is the correct answer" }
                        },
                        required: ["type", "instruction", "question", "answer", "explanation"]
                    },
                    description: "Interactive exercises to practice the concepts",
                    minItems: 3,
                    maxItems: 5
                }
            },
            required: ["title", "grammarFocus", "vocabulary", "commonMistakes", "exercises"]
        };

        const prompt = `Create a structured mini-lesson based on these translation attempts:

${translationList}

Analyze the student's translation patterns and create a comprehensive lesson with:
1. A clear title that describes the main learning focus
2. Grammar focus explaining the key patterns
3. Vocabulary section with 3-5 important words from their translations
4. Common mistakes they made and how to correct them
5. 3-5 interactive exercises of these types:
   - translation: Translate sentences between ${fromLang} and ${toLang}
   - fill-in-blank: Complete sentences with missing words/phrases
   - conjugation: Practice verb conjugations and forms

Make the exercises specific to their translation attempts and provide clear explanations for each answer.`;

        const systemPrompt = `You are a language learning instructor creating structured mini-lessons. Always respond with valid JSON matching the provided schema. Focus on the student's actual translation attempts to create targeted, practical exercises.`;

        try {
            const response = await this.makeStructuredRequest(prompt, schema, systemPrompt);
            return JSON.parse(response);
        } catch (error) {
            console.error('Structured mini lesson generation failed:', error);
            // Fallback to simple lesson format
            const fallbackPrompt = `Create a focused mini-lesson based on these translation attempts:

${translationList}

Analyze the student's translation patterns and create a lesson covering:
1. **Grammar Focus**: Main grammatical patterns and structures the student should learn
2. **Vocabulary**: Key words and their usage from the translations
3. **Common Mistakes**: Patterns you notice in the student's translations
4. **Practice**: 2-3 specific exercises to improve these areas

Focus on the most important learning points from their actual translation attempts. Keep it concise and practical.`;
            
            return await this.makeRequest(fallbackPrompt);
        }
    }

    /**
     * Handle chat/assistant conversations
     */
    async chat(message, context = null) {
        let prompt = message;
        
        if (context) {
            prompt = `Context: ${context}\n\nUser question: ${message}`;
        }

        const systemPrompt = `You are a helpful language learning assistant. Answer questions about grammar, vocabulary, translations, and language learning. Be concise but informative. Use examples when helpful.`;

        return await this.makeRequest(prompt, systemPrompt);
    }
}